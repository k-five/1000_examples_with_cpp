/* Started on November 14th in 2016 */
/* more examples in github.com/k-five */
/*
            Type Support
            ************

Runtime Type Identification (Defined in header <typeinfo>)

    > type_info     contains some type's information, generated by implementation.
                    This is a class returned by typeid operator
    > type_index    wrapper around a type_info object, that can be used as index in associated and unordered
                    associative containers (class)
    > bad_typeid    exception that is thrown if an argument in a typeid expression is null (class)
    > bad_cast      exception that is thrown by  an invalid dynamic_cast expression i.e. cast of reference
                    type fails (class)
*/
/// std::type_index
// The type_index class is a wrapper class around a std::type_info object
// that can be used as index in associative and unordered associative containers.
// The relationship with type_info object is maintained through a pointer, therefore
// type_index is CopyConstructible and CopyAssignable.
//
//    Member functions
//    (constructor)       constructs the object                                           (public member function)
//    (destructor)        (implicitly declared)           destroys the type_index object  (public member function)
//    operator=           (implicitly declared)           assigns a type_index object     (public member function)
//
//    operator==
//    operator!=
//    operator<
//    operator<=
//    operator>
//    operator>=          compares the underlying std::type_info objects                  (public member function)
//    hash_code           returns hashed code                                             (public member function)
//    name                returns implementation defined name of the type,
//                        associated with underlying type_info object                     (public member function)


#include <iostream>
#include <typeinfo>
#include <typeindex>
#include <unordered_map>
#include <string>
#include <memory>

struct A { virtual ~A() {} };

struct B : A {};

struct C : A {};

using TypeinfoRef = std::reference_wrapper<const std::type_info>;

struct Hasher {
    std::size_t operator()( TypeinfoRef code) const { return code.get().hash_code(); }
};

struct EqualTo {
    bool operator()(TypeinfoRef lhs, TypeinfoRef rhs) const { return lhs.get() == rhs.get(); }
};

int main(){
    /// std::size_t hash_code
    // Returns an unspecified value, which is identical for the type_info
    // object referring to the same type. No order guarantees are given.
    // For example, the same value may be returned for different types.
    // The value can also change between invocation of the same program.

    std::unordered_map<TypeinfoRef, std::string, Hasher, EqualTo> type_names;

    type_names[std::type_index(typeid(int))] = "int";       // it gave me error: no match for operator []
    type_names[std::type_index(typeid(double))] = "double";
    type_names[std::type_index(typeid(A))] = "A";
    type_names[std::type_index(typeid(B))] = "B";
    type_names[std::type_index(typeid(C))] = "C";

    int i; double d; A a;

    // note that we are storing pointer to type A
    std::unique_ptr<A> b(new B);
    std::unique_ptr<A> c(new C);

    std::cout << "i is " << type_names[std::type_index(typeid(i))] << '\n';
    std::cout << "d is " << type_names[std::type_index(typeid(d))] << '\n';
    std::cout << "a is " << type_names[std::type_index(typeid(a))] << '\n';
    std::cout << "b is " << type_names[std::type_index(typeid(*b))] << '\n';
    std::cout << "c is " << type_names[std::type_index(typeid(*c))] << '\n';

}
