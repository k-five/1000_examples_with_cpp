/*
Classes
    - class declaration
    - union declaration
    - non-static member data
    - non-static member function    - bit filed
    - static specifier              - this pointer
    - nested class                  - constructor
    - derived class                 - default constructor
    - using declaration             - destructor
    - virtual function specifier    * copy constructor
    - abstract class                - copy assignment operator
    - access specifier              - move constructor
    - friend declaration            - move assignment operator
    - override specifier            - converting operator
    - final specifier               - explicit specifier
***************************************************************
    copy constructor
    A copy constructor of class T is a non-template constructor whose first
    parameter is T&, const T&, volatile T&, or const volatile T&, and either
    there are no other parameter, or the rest of the parameter all have default values.

    Syntax:
    class-name ( const class-name& ){}
    class-name ( const class-name& ) = default;
    class-name ( const class-name& ) = delete;
    first   Typical declaration of a copy constructor
    second  Forcing a copy constructor to be generated by the complier
    third   Avoiding implicit generation of the copy constructor

    The copy constructor is called whenever an object is initialized form another object
    of the same type.
*/

#include <iostream>
#include <string>
#include <sstream>
// #include <cstdlib>

/// Example
// In many situation, copy constructor are optimized out even
// if they would produce observable side-effect

struct A {
    int n;
    A(int i=1):
        n(i) {}
    A(const A& cobj):
        n(cobj.n) {} // user-defined copy constructor
};
struct B: A {
    // implicit default constructor B::B
    // implicit copy constructor B::B(const B&)
};
struct C: B {
    C():
        B() {}
private:
    C(const C&);    // non-copyable, C++98 style
};


int main(){
    A a1(7);
    A a2(a1);   // class the copy constructor

    B b;
    B b2 = b;
    A a3 = b;   // conversion to A& an copy constructor

    volatile A va(10);
//    A a4 = vq;  // compile error

    C c;
//    C c2 = c;   // compile error
}



